	*/
	memset (&sfinfo, 0, sizeof (sfinfo));

	cout <<  "Size of sfinfo = " << sizeof(sfinfo) << endl;

	/* Here's where we open the input file. We pass sf_open the file name an
d
	** a pointer to an SF_INFO struct.
	** On successful open, sf_open returns a SNDFILE* pointer which is used
	** for all subsequent operations on that file.
	** If an error occurs during sf_open, the function returns a NULL pointe
r.
	**
	** If you are trying to open a raw headerless file you will need to set
the
	** format and channels fields of sfinfo before calling sf_open(). For
	** instance to open a raw 16 bit stereo PCM file you would need the foll
owing
	** two lines:
	**
	**		sfinfo.format   = SF_FORMAT_RAW | SF_FORMAT_PCM_16 ;
	**		sfinfo.channels = 2 ;
	*/
	if (! (infile = sf_open(infilename, SFM_READ, &sfinfo)))
	{	/* Open failed so print an error message. */
		printf ("Not able to open input file %s.\n", infilename) ;
		/* Print the error message from libsndfile. */
		puts (sf_strerror (NULL)) ;
		return 1 ;
		} ;

	cout << "There are " << sfinfo.channels << " channels " << endl;
	cout << "frames " << sfinfo.frames << endl;
	cout << "samplerate " << sfinfo.samplerate << endl;
	cout << "format " << sfinfo.format << endl;
	cout << "sections " << sfinfo.sections << endl;
	cout << "seekable " << sfinfo.seekable << endl;//prints string and then variable value

	sf_command (infile, SFC_CALC_SIGNAL_MAX, &signal_max, sizeof (signal_max)) ;
	cout << "Signal MAX is " << signal_max << endl;


	if (sfinfo.channels > MAX_CHANNELS)
	{	printf ("Not able to process more than %d channels\n", MAX_CHANNELS) ;
		return 1 ;
		} ;
	/* Open the output file. */
	if (! (outfile = sf_open (outfilename, SFM_WRITE, &sfinfo)))
	{	printf ("Not able to open output file %s.\n", outfilename) ;
		puts (sf_strerror (NULL)) ;
		return 1 ;
		} ;

	/* While there are.frames in the input file, read them, process
	** them and write them to the output file.
	*/
	while ((readcount = sf_read_short (infile, data, BUFFER_LEN)))
	{
		process_data (data, readcount, sfinfo.channels) ;
		sf_write_short (outfile, data, readcount) ;
		} ;

	/* Close input and output files. */
	sf_close (infile) ;
	sf_close (outfile) ;

	return 0 ;
} /* main */

static void process_data (short *data, int count, int channels)
{
	double channel_gain [MAX_CHANNELS] = {3.5, 1};
	int k, chan ;
	short max = 0;
	short min = 0;//declares variables


	/* Process the data here.
	** If the soundfile contains more then 1 channel you need to take care o
f
	** the data interleaving youself.
	** Current we just apply a channel dependant gain.
	*/

	for (chan = 0 ; chan < channels ; chan ++)
	{
		min, max = data[0];
		for (k = chan ; k < count ; k+= channels)
		{
			data [k] *= channel_gain [chan] ;

			if(k == 0)
			{
				min, max = data[k];
			}
			else if(data[k] > max)
			{
				max = data[k];
			}
			else if(data[k] < min)
			{
				min = data[k];
			}

			if(k < 10)
			{
				cout << "Sample Value = " << data[k] << " , Sample # " << k << endl;
			}
			if(k == count - 1)
			{
				cout << "The last sample is " << k << endl;
			}

		}

	for (chan = 0 ; chan < channels ; chan ++)
	{
		data [k] = 1 / ( max - min )( data[k] - min);

	}

	cout << "The Maximum signed value = " << max << endl;
	cout << "The Minimum signed value = " << min << endl;
	return ;
} /* process_data */
